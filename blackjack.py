#!/usr/bin/env python3

from random import shuffle
from enum import Enum

class Deck(object):
    """
    The Deck object handles card and deck generation.
    """
    CARDS_PER_SINGLE_DECK = 52

    def __init__(self, num_decks = 1, suit_prefixes = ["C", "D", "H", "S"]):
        self.playing_deck = self.generate_playing_deck(num_decks, suit_prefixes)

    # The playing_deck property holds a list of all the cards in the deck.
    # Note that you should only initialize the playing_deck once, and then
    # modify and play (shuffle, draw cards from etc) with the shoe. You should only
    # change the playing_deck if you want to increase the number of card (by using more
    # decks) or change the suit labels of your cards. An update in the playing_deck
    # will reinitialize the shoe so if you modify the playing_deck in the middle of
    # the game, you will ruin your game.
    @property
    def playing_deck(self):
        return self._playing_deck

    @playing_deck.setter
    def playing_deck(self, playing_deck):
        if not self.validate_playing_deck(playing_deck):
            raise Exception("\n\nSomething wrong with your deck. Please use the"
                            " generate_playing_deck()\n""function to generate your deck correctly.")

        self._playing_deck = playing_deck
        self.init_shoe_from_playing_deck()

    @playing_deck.deleter
    def playing_deck(self):
        del self._playing_deck

    # The shoe property holds a list of the cards that haven't been picked
    # while playing.
    @property
    def shoe(self):
        return self._shoe

    @shoe.setter
    def shoe(self, shoe):
        if not self.validate_shoe(shoe):
            raise Exception("\n\nSomething wrong with your shoe. Please ensure that the"
                            " shoe contains\n""cards that already exist in your initial (full) playing_deck.")
        self._shoe = shoe

    @shoe.deleter
    def shoe(self):
        del self._shoe

    #-------------------------------------------------------------
    def _generate_suit(self, suit_string):
        """
        Generate the card labels for a complete suit (13 labels, no joker).

        Arguments:
         suit_string: The string of the suite to generate.

        Returns:
         A list with 13 labels.
        """
        suit = []
        for card in range(1, 14):
            if card == 1: suit.append("{}A".format(suit_string))
            elif card == 11: suit.append("{}J".format(suit_string))
            elif card == 12: suit.append("{}Q".format(suit_string))
            elif card == 13: suit.append("{}K".format(suit_string))
            else: suit.append("{}{}".format(suit_string, card))

        return suit

    #-------------------------------------------------------------
    def _generate_deck(self, suit_labels = ["C", "D", "H", "S"]):
        """
        Generate a single deck with four suits and 52 cards

        Arguments:
         suit_labels: The labels for each suit. All the decks will use the same
                        set of suit labels.

        Returns:
         A list that represents a single deck with 52 cards
        """
        assert isinstance(suit_labels, list), "The number of decks must be an integer."
        suit_labels = list(set(suit_labels)) # Remove duplicate labels
        assert (len(suit_labels) == 4), "A suit must be having 4 labels and no duplicates. {} provided:\n   {}".format(len(suit_labels), ', '.join(suit_labels))

        deck = []
        for label in suit_labels:
            deck.extend(self._generate_suit(label))

        return deck

    #-------------------------------------------------------------
    def get_card_value(self, card):
        """
        Return the numeric (int) value of each card.

        Arguments:
         card: A card that has been generated by the generate_suit() function.

        Returns:
         An integer value. The value of the card.
        """
        value = card[-1]

        if value == "A": return 11
        elif value in ["J", "Q", "K", "0"]: return 10

        return int(value)

    #-------------------------------------------------------------
    def generate_playing_deck(self, number_of_decks = 1, suit_labels = ["C", "D", "H", "S"]):
        """
        Many games require more than one playing decks.
        This function will generate a playing deck with as many decks as needed.

        Arguments:
         number_of_decks: The number of decks that the playing deck will be using.
             suit_labels: The labels for each suit. All the decks will use the same
                            set of suit labels.

        Returns:
         A list with all the cards of the playing deck.
        """
        assert isinstance(number_of_decks, int), "The number of decks must be an integer."

        playing_deck = self._generate_deck(suit_labels)

        return playing_deck * number_of_decks

    #-------------------------------------------------------------
    def validate_playing_deck(self, deck = None):
        """
        Function to validate that all the expected cards exist in the given deck
        Note that this function validates the full set of cards. If you want to
        validate the shoe, use the validate_shoe() function.

        Arguments:
         deck: The deck to validate (a python list)

        Returns:
         True if the validation passes, or False if there is an error
        """
        if deck == None:
            deck = self.playing_deck

        if not isinstance(deck, list): return False
        if not (len(deck) % type(self).CARDS_PER_SINGLE_DECK == 0): return False

        full_decks_in_deck = int(len(deck) / type(self).CARDS_PER_SINGLE_DECK)

        card_count = [0] * 13

        for card in deck:
            if not isinstance(card, str): return False
            value = card[-1]
            if value == "A": card_count[0] += 1
            elif value == "0": card_count[9] += 1
            elif value == "J": card_count[10] += 1
            elif value == "Q": card_count[11] += 1
            elif value == "K": card_count[12] += 1
            else:
                i = int(value)
                card_count[i-1] += 1

        if len(set(card_count)) != 1: return False
        # Each deck has four suits, so since we have already counted how many individual cards
        # were found in the deck, divide by 4 to see if the cards we counted match the number of
        # decks.
        if (card_count[0] / 4 != full_decks_in_deck): return False

        return True

    #-------------------------------------------------------------
    def validate_shoe(self, shoe = None, deck = None):
        """
        Validates the shoe against a deck. The shoe will usually not hold a
        complete set of playing_deck (because players pick cards from the shoe),
        but all the cards in the shoe should exist in the playing deck.

        Arguments:
         shoe: The shoe to validate (A list of cards)

        Returns:
         True if the validation passes, or False otherwise.
        """
        if shoe == None:
            shoe = self.shoe
        if deck == None:
            deck = self.playing_deck

        for card in shoe:
            if card not in deck:
                return False

        return True

    #-------------------------------------------------------------
    def init_shoe_from_playing_deck(self):
        """
        Copies the playing_deck in the shoe and shuffles the shoe.
        Use this function when the shoe doesn't have enough cards to pick from.
        """
        self.shoe = self.playing_deck[:]
        self.shuffle_shoe()

    #-------------------------------------------------------------
    def shuffle_shoe(self):
        """
        Shuffles the shoe
        """
        shuffle(self.shoe)

    #-------------------------------------------------------------
    def pick_card(self):
        """
        Picks one card from the shoe
        """
        if not len(self.shoe):
            self.init_shoe_from_playing_deck()

        return self.shoe.pop()





class Player(object):
    """
    An object that identifies a player
    """
    class ROLE(Enum):
        PLAYER = 0
        DEALER = 1

    def __init__(self, name, role = ROLE.PLAYER):
        self.name = name
        self.role = role
        self.cards = []

    # The role property indicates the type of the player:
    #  normal player or dealer.
    @property
    def role(self):
        return self._role

    @role.setter
    def role(self, role):
        if role not in type(self).ROLE:
            raise Exception("\n\nThe player 'role' should get a valid role from the ROLE enum\n"
                            "'{}' passed.".format(role))
        self._role = role

    @role.getter
    def role(self):
        return self._role

    # The cards property holds a list with the cards of the player
    @property
    def cards(self):
        return self._cards

    @cards.setter
    def cards(self, cards):
        self._cards = cards

    @cards.deleter
    def cards(self):
        del self._cards

    #-------------------------------------------------------------
    def pickCard(self, deck):
        """
        Picks a card from the shoe in the deck and adds the card in the player's
        self.cards list

        Arguments:
         deck: An object of type Deck
        """
        if not isinstance(deck, Deck):
            raise Exception("The 'deck' argument must be of a 'Dect' class type.")

        self.cards.append(deck.pick_card())

    #-------------------------------------------------------------
    def initialPick(self, deck):
        """
        If it is an initial pick, the player should
        get two cards from the shoe

        Arguments:
         deck: a valid deck of cards (Class type Deck)
        """
        self.pickCard(deck)
        self.pickCard(deck)

class blackjack(object):
    #-------------------------------------------------------------
    def __init__(self, deck, players):
        #Arguments:
        #    deck: a valid deck of cards (Class type Deck)
        #    players: A list of the players that play the game.
        self.deck = deck
        self.players = players
        self.validate_players()

    #-------------------------------------------------------------
    def validate_players(self):
        """
        Validates all the players. Only one dealer must be in the game.
        """
        one_dealer_found = False
        for player in self.players:
            if not isinstance(player, Player):
                raise Exception("The player must be an instance of the Class type 'Player'")

            if player.role == Player.ROLE.DEALER:
                if one_dealer_found:
                    raise Exception("Only one dealer is allowed in the game. More than one found.")
                else:
                    one_dealer_found = True

        if not one_dealer_found:
            raise Exception("You must be having one dealer in order to play the game.\n"
                            "No dealer found in the list of available players.")

    #-------------------------------------------------------------
    def is_player_in_game(self, player):
        """
        Check if the given player is in the game.
        """
        if not isinstance(player, Player):
            raise Exception("The player must be an instance of the Class type 'Player'")

        max_name_len = max([len(player.name) for player in self.players])
        if player not in self.players:
            players_in_game = "\n".join(["   {:>{}} ({})".format(player.name, max_name_len, str(player)) for player in self.players])
            raise Exception("\nThe player {} ({}) is not participating in this game.\n"
                            "Players in the game:\n{}".format(player.name, player, players_in_game))

    #-------------------------------------------------------------
    def initPick(self):
        """
        Makes an initial pick (draws two cards) for all the players.
        """
        for player in self.players:
            player.initialPick(self.deck)

    #-------------------------------------------------------------
    def calculate_score(self):
        """
        Calculates the score for all players and returns a dict with the
        name of each player and their numeric sum of cards for quick comparison.

        Returns:
         A dict with the name of each player as the key and the
         numeric sum of the cards of each player as the value.
        """
        scores = {}
        for player in self.players:
            scores[player.name] = sum([self.deck.get_card_value(card) for card in player.cards])

        return scores

    #-------------------------------------------------------------
    def print_cards(self):
        """
        Prints the cards for all players
        """
        # Get the length of the longest name for alignment
        max_name_len = max([len(player.name) for player in self.players])

        # Calculate the score for each player to print a total
        scores = self.calculate_score()

        for player in players:
            print("{:>{}}: {} (Total: {})".format(player.name, max_name_len, ", ".join(player.cards), scores[player.name]))

    #-------------------------------------------------------------
    def pickCard(self, player):
        """
        Picks a card for the given player

        Arguments:
         player: The player to pick a card for.
        """
        self.is_player_in_game(player)
        player.pickCard(self.deck)



if __name__ == "__main__":
    # Just use two players. The dealer and one normal player
    dealer = Player('Dealer', Player.ROLE.DEALER)
    player = Player('Sam')

    players = [dealer, player]

    # Use a single deck
    deck = Deck()
    # Shuffle the deck (The deck is shuffled once on each shoe
    # initialization, but reshuffling doesn't hurt)
    deck.shuffle_shoe()

    blackjack = blackjack(deck, players)

    # Initial pick for all players
    blackjack.initPick()

    # Print the results and the winner
    blackjack.print_cards()

    blackjack.pickCard(dealer)
    blackjack.pickCard(player)

    blackjack.print_cards()
