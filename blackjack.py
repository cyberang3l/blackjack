#!/usr/bin/env python3

from random import shuffle
from enum import Enum

class Deck(object):
    """
    The Deck object handles card and deck generation.
    """
    CARDS_PER_SINGLE_DECK = 52

    def __init__(self, num_decks = 1, suit_prefixes = ["C", "D", "H", "S"]):
        self.playing_deck = self.generate_playing_deck(num_decks, suit_prefixes)

    # The playing_deck property holds a list of all the cards in the deck.
    # Note that you should only initialize the playing_deck once, and then
    # modify and play (shuffle, draw cards from etc) with the shoe. You should only
    # change the playing_deck if you want to increase the number of card (by using more
    # decks) or change the suit labels of your cards. An update in the playing_deck
    # will reinitialize the shoe so if you modify the playing_deck in the middle of
    # the game, you will ruin your game.
    @property
    def playing_deck(self):
        return self._playing_deck

    @playing_deck.setter
    def playing_deck(self, playing_deck):
        if not self.validate_playing_deck(playing_deck):
            raise Exception("\n\nSomething wrong with your deck. Please use the"
                            " generate_playing_deck()\n""function to generate your deck correctly.")

        self._playing_deck = playing_deck
        self.init_shoe_from_playing_deck()

    @playing_deck.deleter
    def playing_deck(self):
        del self._playing_deck

    # The shoe property holds a list of the cards that haven't been picked
    # while playing.
    @property
    def shoe(self):
        return self._shoe

    @shoe.setter
    def shoe(self, shoe):
        if not self.validate_shoe(shoe):
            raise Exception("\n\nSomething wrong with your shoe. Please ensure that the"
                            " shoe contains\n""cards that already exist in your initial (full) playing_deck.")
        self._shoe = shoe

    @shoe.deleter
    def shoe(self):
        del self._shoe

    #-------------------------------------------------------------
    def _generate_suit(self, suit_string):
        """
        Generate the card labels for a complete suit (13 labels, no joker).

        Arguments:
         suit_string: The string of the suite to generate.

        Returns:
         A list with 13 labels.
        """
        suit = []
        for card in range(1, 14):
            if card == 1: suit.append("{}A".format(suit_string))
            elif card == 11: suit.append("{}J".format(suit_string))
            elif card == 12: suit.append("{}Q".format(suit_string))
            elif card == 13: suit.append("{}K".format(suit_string))
            else: suit.append("{}{}".format(suit_string, card))

        return suit

    #-------------------------------------------------------------
    def _generate_deck(self, suit_labels = ["C", "D", "H", "S"]):
        """
        Generate a single deck with four suits and 52 cards

        Arguments:
         suit_labels: The labels for each suit. All the decks will use the same
                        set of suit labels.

        Returns:
         A list that represents a single deck with 52 cards
        """
        assert isinstance(suit_labels, list), "The number of decks must be an integer."
        suit_labels = list(set(suit_labels)) # Remove duplicate labels
        assert (len(suit_labels) == 4), "A suit must be having 4 labels and no duplicates. {} provided:\n   {}".format(len(suit_labels), ', '.join(suit_labels))

        deck = []
        for label in suit_labels:
            deck.extend(self._generate_suit(label))

        return deck

    #-------------------------------------------------------------
    def get_card_value(self, card):
        """
        Return the numeric (int) value of each card.

        Arguments:
         card: A card that has been generated by the generate_suit() function.

        Returns:
         An integer value. The value of the card.
        """
        value = card[-1]

        if value == "A": return 11
        elif value in ["J", "Q", "K", "0"]: return 10

        return int(value)

    #-------------------------------------------------------------
    def generate_playing_deck(self, number_of_decks = 1, suit_labels = ["C", "D", "H", "S"]):
        """
        Many games require more than one playing decks.
        This function will generate a playing deck with as many decks as needed.

        Arguments:
         number_of_decks: The number of decks that the playing deck will be using.
             suit_labels: The labels for each suit. All the decks will use the same
                            set of suit labels.

        Returns:
         A list with all the cards of the playing deck.
        """
        assert isinstance(number_of_decks, int), "The number of decks must be an integer."

        playing_deck = self._generate_deck(suit_labels)

        return playing_deck * number_of_decks

    #-------------------------------------------------------------
    def validate_playing_deck(self, deck = None):
        """
        Function to validate that all the expected cards exist in the given deck
        Note that this function validates the full set of cards. If you want to
        validate the shoe, use the validate_shoe() function.

        Arguments:
         deck: The deck to validate (a python list)

        Returns:
         True if the validation passes, or False if there is an error
        """
        if deck == None:
            deck = self.playing_deck

        if not isinstance(deck, list): return False
        if not (len(deck) % type(self).CARDS_PER_SINGLE_DECK == 0): return False

        full_decks_in_deck = int(len(deck) / type(self).CARDS_PER_SINGLE_DECK)

        card_count = [0] * 13

        for card in deck:
            if not isinstance(card, str): return False
            value = card[-1]
            if value == "A": card_count[0] += 1
            elif value == "0": card_count[9] += 1
            elif value == "J": card_count[10] += 1
            elif value == "Q": card_count[11] += 1
            elif value == "K": card_count[12] += 1
            else:
                i = int(value)
                card_count[i-1] += 1

        if len(set(card_count)) != 1: return False
        # Each deck has four suits, so since we have already counted how many individual cards
        # were found in the deck, divide by 4 to see if the cards we counted match the number of
        # decks.
        if (card_count[0] / 4 != full_decks_in_deck): return False

        return True

    #-------------------------------------------------------------
    def validate_shoe(self, shoe = None, deck = None):
        """
        Validates the shoe against a deck. The shoe will usually not hold a
        complete set of playing_deck (because players pick cards from the shoe),
        but all the cards in the shoe should exist in the playing deck.

        Arguments:
         shoe: The shoe to validate (A list of cards)

        Returns:
         True if the validation passes, or False otherwise.
        """
        if shoe == None:
            shoe = self.shoe
        if deck == None:
            deck = self.playing_deck

        for card in shoe:
            if card not in deck:
                return False

        return True

    #-------------------------------------------------------------
    def init_shoe_from_playing_deck(self):
        """
        Copies the playing_deck in the shoe and shuffles the shoe.
        Use this function when the shoe doesn't have enough cards to pick from.
        """
        self.shoe = self.playing_deck[:]
        self.shuffle_shoe()

    #-------------------------------------------------------------
    def shuffle_shoe(self):
        """
        Shuffles the shoe
        """
        shuffle(self.shoe)

    #-------------------------------------------------------------
    def pick_card(self):
        """
        Picks one card from the shoe
        """
        if not len(self.shoe):
            self.init_shoe_from_playing_deck()

        return self.shoe.pop()





class Player(object):
    """
    An object that identifies a player
    """
    class ROLE(Enum):
        PLAYER = 0
        DEALER = 1

    def __init__(self, name, deck, role = ROLE.PLAYER):
        self.name = name
        self.role = role
        self.deck = deck
        self.cards = []

    # The role property indicates the type of the player:
    #  normal player or dealer.
    @property
    def role(self):
        return self._role

    @role.setter
    def role(self, role):
        if role not in type(self).ROLE:
            raise Exception("\n\nThe player 'role' should get a valid role from the ROLE enum\n"
                            "'{}' passed.".format(role))
        self._role = role

    @role.getter
    def role(self):
        return self._role

    # The deck is the deck where the player is picking cards from
    @property
    def deck(self):
        return self._deck

    @deck.setter
    def deck(self, deck):
        if not isinstance(deck, Deck):
            raise Exception("The deck for each player must be of class type Deck")
        self._deck = deck

    @deck.deleter
    def deck(self):
        del self._deck

    # The cards property holds a list with the cards of the player
    @property
    def cards(self):
        return self._cards

    @cards.setter
    def cards(self, cards):
        self._cards = cards

    @cards.deleter
    def cards(self):
        del self._cards

    #-------------------------------------------------------------
    def pickCard(self):
        """
        Picks a card from the shoe in the deck and adds the card in the player's
        self.cards list
        """

        self.cards.append(self.deck.pick_card())

    #-------------------------------------------------------------
    def initialPick(self):
        """
        If it is an initial pick, the player should
        get two cards from the shoe
        """
        self.pickCard()
        self.pickCard()

    #-------------------------------------------------------------
    def score(self):
        """
        Returns a list with the score for each card that the player
        is currently holding
        """
        return [self.deck.get_card_value(card) for card in self.cards]

    def total_score(self):
        """
        Returns the total score of the cards that the player
        is currently holding
        """
        return sum(self.score())


class blackjack(object):
    #-------------------------------------------------------------
    def __init__(self, deck, dealer, player):
        #Arguments:
        #    deck: a valid deck of cards (Class type Deck)
        #    players: A list of the players that play the game.
        self.deck = deck
        self.dealer = dealer
        self.player = player
        isinstance(self.dealer, Player)
        isinstance(self.player, Player)

        if (self.deck is not self.player.deck) or (self.deck is not self.dealer.deck):
            raise Exception("The Deck should be the same for self.deck, self.dealer.deck, self.player.deck")

    @property
    def player(self):
        return self._player

    @player.setter
    def player(self, player):
        if not self._is_player_role(player, Player.ROLE.PLAYER):
            raise("The active player's role must be Player.ROLE.PLAYER")
        self._player = player

    @player.deleter
    def player(self):
        del self._player

    @property
    def dealer(self):
        return self._dealer

    @dealer.setter
    def dealer(self, dealer):
        if not self._is_player_role(dealer, Player.ROLE.DEALER):
            raise("The active player's role must be Player.ROLE.DEALER")
        self._dealer = dealer

    @dealer.deleter
    def dealer(self):
        del self._dealer

    #-------------------------------------------------------------
    def _is_player_role(self, player, role):
        """
        Function to make a boolean check if a 'player's role is 'role'
        """
        if player.role == role:
            return True
        else:
            return False

    #-------------------------------------------------------------
    def initPick(self):
        """
        Makes an initial pick (draws two cards) for all the players.
        """
        dealer.initialPick()
        player.initialPick()

    #-------------------------------------------------------------
    def print_cards(self):
        """
        Prints the cards for all players
        """
        # Get the length of the longest name for alignment
        max_name_len = max(len(player.name), len(dealer.name))

        print("{:>{}}: {} (Total: {})".format(dealer.name, max_name_len, ", ".join(dealer.cards), dealer.total_score()))
        print("{:>{}}: {} (Total: {})".format(player.name, max_name_len, ", ".join(player.cards), player.total_score()))

    #-------------------------------------------------------------
    def find_winner(self):
        """
        The find_winner function will return a dict with the following information:
        {'winner':Person or None, 'who_draws':None or Person}
        If there is a winner, the winner key will hold the Person class of the winner
        (dealer or player), otherwise it will be empty. Similary, if there is no winner
        yet (thus, the winner is None) the 'who_draws' key will hold the Person class
        of the person that has to pick a card next.
        """
        # If both players pick 21, players wins
        if dealer.total_score() == player.total_score() == 21:
            return {'winner': player, 'who_draws': None}
        # If both players pick 22, dealer wins
        elif dealer.total_score() == player.total_score() == 22:
            return {'winner': dealer, 'who_draws': None}
        # If the dealer has 21,but not the player, the dealer wins
        elif dealer.total_score() == 21:
            return {'winner': dealer, 'who_draws': None}
        # If the player has 21,but not the dealer, the player wins
        elif player.total_score() == 21:
            return {'winner': player, 'who_draws': None}
        # If the players goes over 21, the dealer wins
        elif player.total_score() > 21:
            return {'winner': dealer, 'who_draws': None}
        # If the dealer goes over 21, the player wins
        elif dealer.total_score() > 21:
            return {'winner': player, 'who_draws': None}
        # If the player has less than 17, the player draws card
        elif player.total_score() < 17:
            return {'winner': None, 'who_draws': player}
        # If the player has >= 17 and dealer has less than player, the dealer picks
        elif player.total_score() >= 17 and dealer.total_score() <= player.total_score():
            return {'winner': None, 'who_draws': dealer}
        else:
            return {'winner': dealer, 'who_draws': None}

    #-------------------------------------------------------------
    def autoplay(self, rounds = 1):
        """
        The game will autoplay as many rounds have been told to play
        by the 'rounds' argument.

        Arguments:
         rounds: The number of rounds to play
        """
        # Initial pick for all players

        self.initPick()

        # Print the results and the winner
        res = self.find_winner()
        while not res['winner']:
            res['who_draws'].pickCard()
            res = self.find_winner()

        print(res['winner'].name)
        self.print_cards()




if __name__ == "__main__":
    # Use a single deck
    deck = Deck()
    # Shuffle the deck (The deck is shuffled once on each shoe
    # initialization, but reshuffling doesn't hurt)
    deck.shuffle_shoe()

    # Just use two players. The dealer and one normal player
    dealer = Player('dealer', deck, Player.ROLE.DEALER)
    player = Player('sam', deck)

    blackjack = blackjack(deck, dealer, player)

    blackjack.autoplay()
